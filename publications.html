<!DOCTYPE html>
<html lang="de">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Publications</title>
    <link
      href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;700&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <nav>
      <a href="/">Home </a>
      <a href="cv">CV </a>
      <a href="publications">Publications </a>
      <a href="talks">Talks </a>
      <a href="teaching">Teaching </a>
      <a href="conferences">Organised Conferences </a>
    </nav>

    <div class="content">
      <h1>Publications</h1>
      <p>Please wait a moment; the list may take a few seconds to load.</p>
      <p>
        Otherwise you can find the publications directly via
        <a
          href="https://www.zotero.org/dilanccakir/publications"
          target="_blank"
          rel="noopener"
          >Zotero</a
        >.
      </p>

      <!-- Toolbar: Suche / Filter / PDF -->
      <div class="pub-toolbar">
        <input
          id="pub-search"
          type="search"
          placeholder="Search title, people, venue…"
          aria-label="Search publications"
        />
        <select id="pub-year">
          <option value="">All years</option>
        </select>
        <select id="pub-cat">
          <option value="">All categories</option>
          <option>Books</option>
          <option>Edited Volumes and Issues</option>
          <option>Articles and Chapters</option>
          <option>Blogposts</option>
          <option>Datasets</option>
        </select>
        <button id="pub-reset" type="button">Reset</button>
        <button id="pub-print" type="button">Export as PDF</button>
      </div>

      <div id="loader"><div class="spinner"></div></div>
      <div id="bibliography"></div>
    </div>

    <script>
      const USER_ID = 7858710;

      const ORDER = [
        "Books",
        "Edited Volumes and Issues",
        "Articles and Chapters",
        "Blogposts",
        "Datasets",
      ];

      // --- helpers ---
      const yearOf = (d) => {
        const m = String(d?.date || "").match(/\b(19|20)\d{2}\b/);
        return m ? +m[0] : 0;
      };

      const joinNames = (arr = []) =>
        arr
          .map((c) =>
            c.name
              ? c.name
              : [c.lastName, c.firstName].filter(Boolean).join(", ")
          )
          .filter(Boolean)
          .join("; ");

      const detectCategory = (it) => {
        const t = it.data.itemType;
        const has = (role) =>
          (it.data.creators || []).some((c) => c.creatorType === role);
        if (t === "book" && has("author")) return "Books";
        if (t === "book" && !has("author") && has("editor"))
          return "Edited Volumes and Issues";
        if (["journalArticle", "bookSection", "conferencePaper"].includes(t))
          return "Articles and Chapters";
        if (t === "dataset") return "Datasets";
        return "Blogposts";
      };

      // Venue (Journal/Buch/Proceedings/Ort/Verlag) + Editor:innen in Klammern
      function buildVenue(d) {
        const place = d.place || d.publisherPlace || d.eventPlace || "";
        const publisher = d.publisher || "";
        const editors = joinNames(
          (d.creators || []).filter((c) => c.creatorType === "editor")
        );
        const edStr = editors ? ` (ed. ${editors})` : "";
        const vol = d.volume ? ` ${d.volume}` : "";
        const issue = d.issue ? `(${d.issue})` : "";
        const pages = d.pages ? `, pp. ${d.pages}` : "";

        if (d.itemType === "journalArticle") {
          const journal = d.publicationTitle || "";
          // Journal + evtl. (ed. …) für Sonderhefte
          return [
            journal && `<em>${journal}</em>${edStr}${vol}${issue}${pages}`,
          ]
            .filter(Boolean)
            .join("");
        }

        if (d.itemType === "bookSection") {
          const inBook = d.bookTitle ? `In: ${d.bookTitle}` : "";
          const pubStr =
            publisher || place
              ? ` — ${[publisher, place].filter(Boolean).join(", ")}`
              : "";
          return [inBook && `<em>${inBook}</em>${edStr}`, pubStr]
            .filter(Boolean)
            .join("");
        }

        if (d.itemType === "conferencePaper") {
          const proc = d.proceedingsTitle || d.conferenceName || "";
          const where = [publisher, place].filter(Boolean).join(", ");
          return [
            proc && `<em>${proc}</em>${edStr}`,
            where && ` — ${where}`,
            pages,
          ]
            .filter(Boolean)
            .join("");
        }

        if (d.itemType === "book") {
          const where = [publisher, place].filter(Boolean).join(", ");
          return where ? `<em>${where}</em>` : "";
        }

        if (d.itemType === "dataset") {
          const repo = d.repository || d.archive || "";
          const where = [repo || publisher || "", place || ""]
            .filter(Boolean)
            .join(", ");
          return where ? `<em>${where}</em>` : "";
        }

        // Blogposts / Web etc.
        const pubTitle = d.publicationTitle || d.websiteTitle || d.series || "";
        const where = [pubTitle || publisher || "", place || ""]
          .filter(Boolean)
          .join(", ");
        return where ? `<em>${where}</em>` : "";
      }

      // --- state ---
      let allItems = [];
      let groups = {};
      let years = [];

      // Rendering eines Items:
      // - Autoren ohne Label
      // - Editor:innen NICHT separat; sie erscheinen nur in Klammern bei Venue bzw. (bei reinen Herausgeberbänden) hinter dem Titel
      const renderItem = (it, cat) => {
        const d = it.data;
        const y = yearOf(d);
        const authors = joinNames(
          (d.creators || []).filter((c) => c.creatorType === "author")
        );
        const editors = joinNames(
          (d.creators || []).filter((c) => c.creatorType === "editor")
        );
        const title = d.title || "(Untitled)";
        const link = d.DOI ? "https://doi.org/" + d.DOI : d.url || "";
        const venue = buildVenue(d);
        const extra = d.extra ? d.extra.trim() : "";
        const yearStr = y ? ` · ${y}` : "";
        const extraStr = extra
          ? ` · <span class="pub-extra">${extra}</span>`
          : "";

        // Bei Edited Volumes and Issues: (ed. …) direkt hinter den Titel
        const titleWithEditors =
          cat === "Edited Volumes and Issues" && editors
            ? `${title} <span class="pub-editors">(ed. ${editors})</span>`
            : title;

        // Personenzeile: nur Autor:innen, ohne Label
        const peopleLine = authors ? authors : "";

        // Metazeile zusammenbauen (ohne doppelte Editor-Nennung)
        const metaParts = [];
        if (peopleLine) metaParts.push(peopleLine);
        if (venue) metaParts.push(venue);

        return `
          <li class="pub-item" data-year="${y}">
            <span class="pub-title">${titleWithEditors}</span>
            <span class="pub-meta">
              ${metaParts.join(" — ")}${yearStr}${extraStr}
              ${
                link
                  ? ` · <a class="pub-link" href="${link}" target="_blank" rel="noopener">${
                      d.DOI ? "DOI" : "Link"
                    }</a>`
                  : ""
              }
            </span>
          </li>`;
      };

      function rebuildGroups(items) {
        const g = {};
        for (const it of items) (g[detectCategory(it)] ||= []).push(it);
        for (const c in g) g[c].sort((a, b) => yearOf(b.data) - yearOf(a.data));
        return g;
      }

      function render(groupsToRender) {
        const container = document.getElementById("bibliography");
        const html =
          ORDER.filter((c) => groupsToRender[c]?.length)
            .map(
              (c) => `
            <section class="pub-section" data-cat="${c}">
              <h2>${c}</h2>
              <ol class="pub-list">${groupsToRender[c]
                .map((it) => renderItem(it, c))
                .join("")}</ol>
            </section>
          `
            )
            .join("") || "<p>No entries.</p>";
        container.innerHTML = html;
      }

      // Filter
      function buildYearList(items) {
        const set = new Set(items.map((it) => yearOf(it.data)).filter(Boolean));
        return Array.from(set).sort((a, b) => b - a);
      }

      function applyFilters() {
        const q = document
          .getElementById("pub-search")
          .value.trim()
          .toLowerCase();
        const yf = document.getElementById("pub-year").value;
        const cf = document.getElementById("pub-cat").value;

        const filtered = allItems.filter((it) => {
          if (cf && detectCategory(it) !== cf) return false;
          const y = yearOf(it.data);
          if (yf && String(y) !== yf) return false;
          if (q) {
            const d = it.data;
            const hay = [
              d.title,
              joinNames(d.creators || []),
              buildVenue(d).replace(/<[^>]+>/g, ""),
              d.extra || "",
            ]
              .join(" ")
              .toLowerCase();
            if (!hay.includes(q)) return false;
          }
          return true;
        });

        const g = rebuildGroups(filtered);
        render(g);
      }

      function resetFilters() {
        document.getElementById("pub-search").value = "";
        document.getElementById("pub-year").value = "";
        document.getElementById("pub-cat").value = "";
        render(groups);
      }

      // init
      async function loadPublications() {
        const box = document.getElementById("bibliography");
        box.innerHTML = "<p>Loading publications…</p>";
        document.getElementById("loader")?.classList.remove("hidden");
        try {
          const url = `https://api.zotero.org/users/${USER_ID}/publications/items?format=json&sort=date&direction=desc&limit=200`;
          const res = await fetch(url, {
            headers: { "Zotero-API-Version": "3" },
          });
          if (!res.ok) throw new Error("Zotero API: " + res.status);
          allItems = await res.json();

          groups = rebuildGroups(allItems);
          const years = buildYearList(allItems);
          const yearSel = document.getElementById("pub-year");
          years.forEach((y) => {
            const opt = document.createElement("option");
            opt.value = String(y);
            opt.textContent = y;
            yearSel.appendChild(opt);
          });

          render(groups);
        } catch (e) {
          console.error(e);
          box.innerHTML = `<p>Couldn't load publications. See them on <a href="https://www.zotero.org/dilanccakir/publications" target="_blank" rel="noopener">Zotero</a>.</p>`;
        } finally {
          document.getElementById("loader")?.classList.add("hidden");
        }
      }

      // events
      document
        .getElementById("pub-search")
        .addEventListener("input", applyFilters);
      document
        .getElementById("pub-year")
        .addEventListener("change", applyFilters);
      document
        .getElementById("pub-cat")
        .addEventListener("change", applyFilters);
      document
        .getElementById("pub-reset")
        .addEventListener("click", resetFilters);
      document
        .getElementById("pub-print")
        .addEventListener("click", () => window.print());

      loadPublications();
    </script>

    <style>
      .pub-toolbar {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        align-items: center;
        margin: 0 0 1rem 0;
      }
      .pub-toolbar input[type="search"],
      .pub-toolbar select {
        padding: 0.4rem 0.6rem;
        border: 1px solid #ddd;
        border-radius: 0.4rem;
        font: inherit;
      }
      .pub-toolbar button {
        padding: 0.45rem 0.7rem;
        border: 1px solid #222;
        background: transparent;
        border-radius: 0.5rem;
        cursor: pointer;
      }
      .pub-toolbar button:hover {
        background: #f5f5f5;
      }

      .pub-section {
        margin: 2rem 0 2.5rem;
      }
      .pub-section h2 {
        margin-bottom: 0.6rem;
        font-weight: 600;
      }
      .pub-list {
        margin-left: 0;
        padding-left: 0;
        list-style: none;
      }
      .pub-item {
        margin: 0.6rem 0 0.85rem;
        line-height: 1.55;
      }
      .pub-title {
        display: block;
        font-weight: 600;
      }
      .pub-editors {
        font-weight: 400;
        color: #555;
      }
      .pub-meta {
        display: block;
        font-size: 0.95em;
        color: #555;
        margin-top: 0.12rem;
      }
      .pub-extra {
        font-style: italic;
        color: #666;
      }
      .pub-link {
        padding: 0.1rem 0.4rem;
        border: 1px solid currentColor;
        border-radius: 0.4rem;
        text-decoration: none;
        font-size: 0.88em;
      }
      .pub-item + .pub-item {
        padding-top: 0.55rem;
        border-top: 1px dashed rgba(0, 0, 0, 0.08);
      }
      #loader.hidden {
        display: none;
      }
      em {
        font-style: italic;
      }

      /* Print/PDF */
      @media print {
        nav,
        .pub-toolbar,
        #loader {
          display: none !important;
        }
        a[href]:after {
          content: " (" attr(href) ")";
          font-size: 0.85em;
        }
        .pub-section {
          page-break-inside: avoid;
        }
        .pub-item {
          border: none !important;
        }
      }
    </style>
  </body>
</html>
